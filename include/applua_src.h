/* Auto-generated from ../app.lua */
#ifndef APP_LUA_H
#define APP_LUA_H

const char* app_lua_source =
    "local core = {}\n"
    "core.routes = {}\n"
    "local etlua = require(\"etlua\")\n"
    "-- Helper to create a response object with chainable methods\n"
    "-- Internal helper to create the chainable response\n"
    "local function create_response(body)\n"
    "    local resp = {\n"
    "        status_code = 200,\n"
    "        body = body or \"\",\n"
    "        headers = { [\"Content-Type\"] = \"text/html\" }\n"
    "    }\n"
    "    function resp:status(code)\n"
    "        self.status_code = code; return self\n"
    "    end\n"
    "\n"
    "    function resp:header(k, v)\n"
    "        self.headers[k] = v; return self\n"
    "    end\n"
    "\n"
    "    function resp:type(mime_type)\n"
    "        self.headers[\"Content-Type\"] = mime_type\n"
    "        return self\n"
    "    end\n"
    "\n"
    "    return resp\n"
    "end\n"
    "\n"
    "-- Render function\n"
    "function core.render(view_name, data)\n"
    "    -- 1. Security Check: Block directory traversal attempts\n"
    "    if view_name:find(\"%.%.\") then\n"
    "        return create_response(\"Security Error: Invalid view name\"):status(403)\n"
    "    end\n"
    "\n"
    "    -- 2. Normalize PLUGIN_DIR: Remove trailing slash if it exists, then add one\n"
    "    local base_path = PLUGIN_DIR:gsub(\"/$\", \"\") .. \"/\"\n"
    "\n"
    "    -- 3. Construct absolute path\n"
    "    local path = base_path .. \"views/\" .. view_name .. \".etlua\"\n"
    "\n"
    "    -- 4. Safe File Loading\n"
    "    local f = io.open(path, \"r\")\n"
    "    if not f then\n"
    "        -- Log to C stderr for debugging, return 404/500 to browser\n"
    "        io.stderr:write(\"Render Error: File not found at \" .. path .. \"\\n\")\n"
    "        return create_response(\"Template not found\"):status(500)\n"
    "    end\n"
    "\n"
    "    local content = f:read(\"*a\")\n"
    "    f:close()\n"
    "\n"
    "    -- 5. Robust Compilation & Execution\n"
    "    -- We use pcall to ensure a Lua error in the template doesn't crash the request\n"
    "    local ok_compile, template = pcall(etlua.compile, content)\n"
    "    if not ok_compile then\n"
    "        return create_response(\"Template Syntax Error: \" .. tostring(template)):status(500)\n"
    "    end\n"
    "\n"
    "    local ok_render, html = pcall(template, data)\n"
    "    if not ok_render then\n"
    "        return create_response(\"Template Runtime Error: \" .. tostring(html)):status(500)\n"
    "    end\n"
    "\n"
    "    -- Explicitly set HTML type since we are rendering a template\n"
    "    return create_response(html):type(\"text/html\")\n"
    "end\n"
    "\n"
    "-- Routing logic\n"
    "function core.match(method, path, handler)\n"
    "    method = method:upper()\n"
    "    core.routes[method] = core.routes[method] or {}\n"
    "    core.routes[method][path] = handler\n"
    "end\n"
    "\n"
    "function core.get(path, handler) core.match(\"GET\", path, handler) end\n"
    "\n"
    "-- Updated Dispatcher\n"
    "function core.handle_request(req)\n"
    "    local method = req.method:upper()\n"
    "    if core.routes[method] and core.routes[method][req.url] then\n"
    "        local result = core.routes[method][req.url](req)\n"
    "\n"
    "        -- Convert the chainable object back to a plain table for C\n"
    "        return {\n"
    "            status = result.status_code,\n"
    "            body = result.body,\n"
    "            headers = result.headers\n"
    "        }\n"
    "    end\n"
    "    return { status = 404, body = \"Not Found\", headers = {} }\n"
    "end\n"
    "\n"
    "return core\n";

#endif /* APP_LUA_H */

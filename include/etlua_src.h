/* Auto-generated from etlua.lua */
#ifndef ETLUA_SOURCE_H
#define ETLUA_SOURCE_H

const char* etlua_source =
    "local VERSION = \"1.3.0\"\n"
    "local insert, concat\n"
    "do\n"
    "  local _obj_0 = table\n"
    "  insert, concat = _obj_0.insert, _obj_0.concat\n"
    "end\n"
    "local load, setfenv, assert, type, error, tostring, tonumber, setmetatable\n"
    "do\n"
    "  local _obj_0 = _G\n"
    "  load, setfenv, assert, type, error, tostring, tonumber, setmetatable = _obj_0.load, _obj_0.setfenv, _obj_0.assert, _obj_0.type, _obj_0.error, _obj_0.tostring, _obj_0.tonumber, _obj_0.setmetatable\n"
    "end\n"
    "setfenv = setfenv or function(fn, env)\n"
    "  local name\n"
    "  local i = 1\n"
    "  while true do\n"
    "    name = debug.getupvalue(fn, i)\n"
    "    if not name or name == \"_ENV\" then\n"
    "      break\n"
    "    end\n"
    "    i = i + 1\n"
    "  end\n"
    "  if name then\n"
    "    debug.upvaluejoin(fn, i, (function()\n"
    "      return env\n"
    "    end), 1)\n"
    "  end\n"
    "  return fn\n"
    "end\n"
    "local html_escape_entities = {\n"
    "  ['&'] = '&amp;',\n"
    "  ['<'] = '&lt;',\n"
    "  ['>'] = '&gt;',\n"
    "  ['\"'] = '&quot;',\n"
    "  [\"'\"] = '&#039;'\n"
    "}\n"
    "local html_escape\n"
    "html_escape = function(str)\n"
    "  return (str:gsub([=[[\"><'&]]=], html_escape_entities))\n"
    "end\n"
    "local get_line\n"
    "get_line = function(str, line_num)\n"
    "  for line in str:gmatch(\"([^\\n]*)\\n?\") do\n"
    "    if line_num == 1 then\n"
    "      return line\n"
    "    end\n"
    "    line_num = line_num - 1\n"
    "  end\n"
    "end\n"
    "local pos_to_line\n"
    "pos_to_line = function(str, pos)\n"
    "  local line = 1\n"
    "  for _ in str:sub(1, pos):gmatch(\"\\n\") do\n"
    "    line = line + 1\n"
    "  end\n"
    "  return line\n"
    "end\n"
    "local Compiler\n"
    "do\n"
    "  local _class_0\n"
    "  local _base_0 = {\n"
    "    html_escape = true,\n"
    "    render = function(self)\n"
    "      return table.concat(self.buffer)\n"
    "    end,\n"
    "    push = function(self, str, ...)\n"
    "      local i = self.i + 1\n"
    "      self.buffer[i] = str\n"
    "      self.i = i\n"
    "      if ... then\n"
    "        return self:push(...)\n"
    "      end\n"
    "    end,\n"
    "    header = function(self)\n"
    "      return self:push(\"local _tostring, _escape, _b, _b_i = ...\\n\")\n"
    "    end,\n"
    "    footer = function(self)\n"
    "      return self:push(\"return _b\")\n"
    "    end,\n"
    "    increment = function(self)\n"
    "      return self:push(\"_b_i = _b_i + 1\\n\")\n"
    "    end,\n"
    "    mark = function(self, pos)\n"
    "      return self:push(\"--[[\", tostring(pos), \"]] \")\n"
    "    end,\n"
    "    assign = function(self, ...)\n"
    "      self:push(\"_b[_b_i] = \", ...)\n"
    "      if ... then\n"
    "        return self:push(\"\\n\")\n"
    "      end\n"
    "    end,\n"
    "    compile_chunks = function(self, chunks)\n"
    "      self:header()\n"
    "      for _index_0 = 1, #chunks do\n"
    "        local chunk = chunks[_index_0]\n"
    "        local t = type(chunk)\n"
    "        if t == \"table\" then\n"
    "          t = chunk[1]\n"
    "        end\n"
    "        local _exp_0 = t\n"
    "        if \"string\" == _exp_0 then\n"
    "          self:increment()\n"
    "          self:assign((\"%q\"):format(chunk))\n"
    "        elseif \"code\" == _exp_0 then\n"
    "          self:mark(chunk[3])\n"
    "          self:push(chunk[2], \"\\n\")\n"
    "        elseif \"=\" == _exp_0 or \"-\" == _exp_0 then\n"
    "          self:increment()\n"
    "          self:mark(chunk[3])\n"
    "          self:assign()\n"
    "          if t == \"=\" and self.html_escape then\n"
    "            self:push(\"_escape(_tostring(\", chunk[2], \"))\\n\")\n"
    "          else\n"
    "            self:push(\"_tostring(\", chunk[2], \")\\n\")\n"
    "          end\n"
    "        else\n"
    "          error(\"unknown type \" .. tostring(t))\n"
    "        end\n"
    "      end\n"
    "      self:footer()\n"
    "      return self:render()\n"
    "    end\n"
    "  }\n"
    "  _base_0.__index = _base_0\n"
    "  _class_0 = setmetatable({\n"
    "    __init = function(self)\n"
    "      self.buffer = { }\n"
    "      self.i = 0\n"
    "    end,\n"
    "    __base = _base_0,\n"
    "    __name = \"Compiler\"\n"
    "  }, {\n"
    "    __index = _base_0,\n"
    "    __call = function(cls, ...)\n"
    "      local _self_0 = setmetatable({}, _base_0)\n"
    "      cls.__init(_self_0, ...)\n"
    "      return _self_0\n"
    "    end\n"
    "  })\n"
    "  _base_0.__class = _class_0\n"
    "  Compiler = _class_0\n"
    "end\n"
    "local Parser\n"
    "do\n"
    "  local _class_0\n"
    "  local _base_0 = {\n"
    "    open_tag = \"<%\",\n"
    "    close_tag = \"%>\",\n"
    "    modifiers = \"^[=-]\",\n"
    "    next_tag = function(self)\n"
    "      local start, stop = self.str:find(self.open_tag, self.pos, true)\n"
    "      if not (start) then\n"
    "        self:push_raw(self.pos, #self.str)\n"
    "        return false\n"
    "      end\n"
    "      if not (start == self.pos) then\n"
    "        self:push_raw(self.pos, start - 1)\n"
    "      end\n"
    "      self.pos = stop + 1\n"
    "      local modifier\n"
    "      if self.str:match(self.modifiers, self.pos) then\n"
    "        do\n"
    "          local _with_0 = self.str:sub(self.pos, self.pos)\n"
    "          self.pos = self.pos + 1\n"
    "          modifier = _with_0\n"
    "        end\n"
    "      end\n"
    "      local close_start, close_stop = self.str:find(self.close_tag, self.pos, true)\n"
    "      if not (close_start) then\n"
    "        return nil, self:error_for_pos(start, \"failed to find closing tag\")\n"
    "      end\n"
    "      while self:in_string(self.pos, close_start) do\n"
    "        close_start, close_stop = self.str:find(self.close_tag, close_stop, true)\n"
    "        if not (close_start) then\n"
    "          return nil, self:error_for_pos(start, \"failed to find string close\")\n"
    "        end\n"
    "      end\n"
    "      local trim_newline\n"
    "      if \"-\" == self.str:sub(close_start - 1, close_start - 1) then\n"
    "        close_start = close_start - 1\n"
    "        trim_newline = true\n"
    "      end\n"
    "      self:push_code(modifier or \"code\", self.pos, close_start - 1)\n"
    "      self.pos = close_stop + 1\n"
    "      if trim_newline then\n"
    "        do\n"
    "          local match = self.str:match(\"^\\n\", self.pos)\n"
    "          if match then\n"
    "            self.pos = self.pos + #match\n"
    "          end\n"
    "        end\n"
    "      end\n"
    "      return true\n"
    "    end,\n"
    "    in_string = function(self, start, stop)\n"
    "      local in_string = false\n"
    "      local end_delim = nil\n"
    "      local escape = false\n"
    "      local pos = 0\n"
    "      local skip_until = nil\n"
    "      local chunk = self.str:sub(start, stop)\n"
    "      for char in chunk:gmatch(\".\") do\n"
    "        local _continue_0 = false\n"
    "        repeat\n"
    "          pos = pos + 1\n"
    "          if skip_until then\n"
    "            if pos <= skip_until then\n"
    "              _continue_0 = true\n"
    "              break\n"
    "            end\n"
    "            skip_until = nil\n"
    "          end\n"
    "          if end_delim then\n"
    "            if end_delim == char and not escape then\n"
    "              in_string = false\n"
    "              end_delim = nil\n"
    "            end\n"
    "          else\n"
    "            if char == \"'\" or char == '\"' then\n"
    "              end_delim = char\n"
    "              in_string = true\n"
    "            end\n"
    "            if char == \"[\" then\n"
    "              do\n"
    "                local lstring = chunk:match(\"^%[=*%[\", pos)\n"
    "                if lstring then\n"
    "                  local lstring_end = lstring:gsub(\"%[\", \"]\")\n"
    "                  local lstring_p1, lstring_p2 = chunk:find(lstring_end, pos, true)\n"
    "                  if not (lstring_p1) then\n"
    "                    return true\n"
    "                  end\n"
    "                  skip_until = lstring_p2\n"
    "                end\n"
    "              end\n"
    "            end\n"
    "          end\n"
    "          escape = char == \"\\\\\"\n"
    "          _continue_0 = true\n"
    "        until true\n"
    "        if not _continue_0 then\n"
    "          break\n"
    "        end\n"
    "      end\n"
    "      return in_string\n"
    "    end,\n"
    "    push_raw = function(self, start, stop)\n"
    "      return insert(self.chunks, self.str:sub(start, stop))\n"
    "    end,\n"
    "    push_code = function(self, kind, start, stop)\n"
    "      return insert(self.chunks, {\n"
    "        kind,\n"
    "        self.str:sub(start, stop),\n"
    "        start\n"
    "      })\n"
    "    end,\n"
    "    compile = function(self, str)\n"
    "      local success, err = self:parse(str)\n"
    "      if not (success) then\n"
    "        return nil, err\n"
    "      end\n"
    "      local fn\n"
    "      fn, err = self:load(self:chunks_to_lua())\n"
    "      if not (fn) then\n"
    "        return nil, err\n"
    "      end\n"
    "      return function(...)\n"
    "        local buffer\n"
    "        buffer, err = self:run(fn, ...)\n"
    "        if buffer then\n"
    "          return concat(buffer)\n"
    "        else\n"
    "          return nil, err\n"
    "        end\n"
    "      end\n"
    "    end,\n"
    "    parse = function(self, str)\n"
    "      self.str = str\n"
    "      assert(type(self.str) == \"string\", \"expecting string for parse\")\n"
    "      self.pos = 1\n"
    "      self.chunks = { }\n"
    "      while true do\n"
    "        local found, err = self:next_tag()\n"
    "        if err then\n"
    "          return nil, err\n"
    "        end\n"
    "        if not (found) then\n"
    "          break\n"
    "        end\n"
    "      end\n"
    "      return true\n"
    "    end,\n"
    "    parse_error = function(self, err, code)\n"
    "      local line_no, err_msg = err:match(\"%[.-%]:(%d+): (.*)$\")\n"
    "      line_no = tonumber(line_no)\n"
    "      if not (line_no) then\n"
    "        return \n"
    "      end\n"
    "      local line = get_line(code, line_no)\n"
    "      local source_pos = tonumber(line:match(\"^%-%-%[%[(%d+)%]%]\"))\n"
    "      if not (source_pos) then\n"
    "        return \n"
    "      end\n"
    "      return self:error_for_pos(source_pos, err_msg)\n"
    "    end,\n"
    "    error_for_pos = function(self, source_pos, err_msg)\n"
    "      local source_line_no = pos_to_line(self.str, source_pos)\n"
    "      local source_line = get_line(self.str, source_line_no)\n"
    "      return tostring(err_msg) .. \" [\" .. tostring(source_line_no) .. \"]: \" .. tostring(source_line)\n"
    "    end,\n"
    "    load = function(self, code, name)\n"
    "      if name == nil then\n"
    "        name = \"etlua\"\n"
    "      end\n"
    "      local code_fn\n"
    "      do\n"
    "        local code_ref = code\n"
    "        code_fn = function()\n"
    "          do\n"
    "            local ret = code_ref\n"
    "            code_ref = nil\n"
    "            return ret\n"
    "          end\n"
    "        end\n"
    "      end\n"
    "      local fn, err = load(code_fn, name)\n"
    "      if not (fn) then\n"
    "        do\n"
    "          local err_msg = self:parse_error(err, code)\n"
    "          if err_msg then\n"
    "            return nil, err_msg\n"
    "          end\n"
    "        end\n"
    "        return nil, err\n"
    "      end\n"
    "      return fn\n"
    "    end,\n"
    "    run = function(self, fn, env, buffer, i, ...)\n"
    "      if env == nil then\n"
    "        env = { }\n"
    "      end\n"
    "      local combined_env = setmetatable({ }, {\n"
    "        __index = function(self, name)\n"
    "          local val = env[name]\n"
    "          if val == nil then\n"
    "            val = _G[name]\n"
    "          end\n"
    "          return val\n"
    "        end\n"
    "      })\n"
    "      if not (buffer) then\n"
    "        buffer = { }\n"
    "        i = 0\n"
    "      end\n"
    "      setfenv(fn, combined_env)\n"
    "      return fn(tostring, html_escape, buffer, i, ...)\n"
    "    end,\n"
    "    compile_to_lua = function(self, str, ...)\n"
    "      local success, err = self:parse(str)\n"
    "      if not (success) then\n"
    "        return nil, err\n"
    "      end\n"
    "      return self:chunks_to_lua(...)\n"
    "    end,\n"
    "    chunks_to_lua = function(self, compiler_cls)\n"
    "      if compiler_cls == nil then\n"
    "        compiler_cls = Compiler\n"
    "      end\n"
    "      return compiler_cls():compile_chunks(self.chunks)\n"
    "    end\n"
    "  }\n"
    "  _base_0.__index = _base_0\n"
    "  _class_0 = setmetatable({\n"
    "    __init = function() end,\n"
    "    __base = _base_0,\n"
    "    __name = \"Parser\"\n"
    "  }, {\n"
    "    __index = _base_0,\n"
    "    __call = function(cls, ...)\n"
    "      local _self_0 = setmetatable({}, _base_0)\n"
    "      cls.__init(_self_0, ...)\n"
    "      return _self_0\n"
    "    end\n"
    "  })\n"
    "  _base_0.__class = _class_0\n"
    "  Parser = _class_0\n"
    "end\n"
    "local compile\n"
    "do\n"
    "  local _base_0 = Parser()\n"
    "  local _fn_0 = _base_0.compile\n"
    "  compile = function(...)\n"
    "    return _fn_0(_base_0, ...)\n"
    "  end\n"
    "end\n"
    "local render\n"
    "render = function(str, ...)\n"
    "  local fn, err = compile(str)\n"
    "  if fn then\n"
    "    return fn(...)\n"
    "  else\n"
    "    return nil, err\n"
    "  end\n"
    "end\n"
    "return {\n"
    "  compile = compile,\n"
    "  render = render,\n"
    "  Parser = Parser,\n"
    "  Compiler = Compiler,\n"
    "  _version = VERSION\n"
    "}\n"
;

#endif
